{"version":3,"sources":["elements.umd.js"],"names":["global","factory","exports","module","require","define","amd","ng","elements","core","Rx","Observable","prototype","this","_angular_core","rxjs_observable_merge","rxjs_operator_map","__extends","d","b","__","constructor","extendStatics","Object","create","camelToDashCase","input","replace","char","toLowerCase","createCustomEvent","doc","name","detail","CustomEvent","event_1","createEvent","initCustomEvent","bubbles","cancelable","isElement","node","nodeType","Node","ELEMENT_NODE","isFunction","value","matchesSelector","element","selector","matches","call","strictEquals","value1","value2","extractProjectableNodes","host","ngContentSelectors","nodes","childNodes","projectableNodes","map","wildcardIndex","some","i","ii","length","ngContentIndex","findMatchingIndex","push","selectors","defaultIndex","matchingIndex","getDefaultAttributeToPropertyInputs","inputs","attributeToPropertyInputs","forEach","_a","propName","templateName","getComponentInputs","component","injector","get","ComponentFactoryResolver","resolveComponentFactory","createNgElementConstructor","config","strategyFactory","ComponentNgElementStrategyFactory","NgElementImpl","_super","_this","ngElementStrategy","attributeChangedCallback","attrName","oldValue","newValue","namespace","setInputValue","connectedCallback","connect","ngElementEventsSubscription","events","subscribe","e","customEvent","ownerDocument","dispatchEvent","disconnectedCallback","disconnect","unsubscribe","observedAttributes","keys","NgElement","property","defineProperty","getInputValue","set","configurable","enumerable","setPrototypeOf","__proto__","Array","p","hasOwnProperty","elProto","Element","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","scheduler","schedule","taskFn","delay","id","window","setTimeout","clearTimeout","scheduleBeforeRender","requestAnimationFrame","cancelAnimationFrame","componentFactory","ComponentNgElementStrategy","inputChanges","implementsOnChanges","scheduledChangeDetectionFn","scheduledDestroyFn","initialInputValues","Map","uninitializedInputs","Set","componentRef","initializeComponent","destroy","recordInputChange","scheduleDetectChanges","childInjector","Injector","providers","parent","ngOnChanges","initializeInputs","initializeOutputs","detectChanges","ApplicationRef","attachView","hostView","initialValue","add","clear","eventEmitters","outputs","emitter","merge","apply","callNgOnChanges","currentValue","pendingChange","isFirstChange","has","delete","previousValue","undefined","SimpleChange","changeDetectorRef","arguments","HTMLElement","VERSION","Version"],"mappings":"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","file":"elements.umd.min.js","sourcesContent":["/**\n * @license Angular v6.0.0-beta.6-10cd543ab9\n * (c) 2010-2018 Google, Inc. https://angular.io/\n * License: MIT\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs/observable/merge'), require('rxjs/operator/map')) :\n\ttypeof define === 'function' && define.amd ? define('@angular/elements', ['exports', '@angular/core', 'rxjs/observable/merge', 'rxjs/operator/map'], factory) :\n\t(factory((global.ng = global.ng || {}, global.ng.elements = {}),global.ng.core,global.Rx.Observable,global.Rx.Observable.prototype));\n}(this, (function (exports,_angular_core,rxjs_observable_merge,rxjs_operator_map) { 'use strict';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/**\n * @license Angular v6.0.0-beta.6-10cd543ab9\n * (c) 2010-2018 Google, Inc. https://angular.io/\n * License: MIT\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar elProto = /** @type {?} */ (Element.prototype);\nvar matches = elProto.matches || elProto.matchesSelector || elProto.mozMatchesSelector ||\n    elProto.msMatchesSelector || elProto.oMatchesSelector || elProto.webkitMatchesSelector;\n/**\n * Provide methods for scheduling the execution of a callback.\n */\nvar scheduler = {\n    /**\n     * Schedule a callback to be called after some delay.\n     *\n     * Returns a function that when executed will cancel the scheduled function.\n     */\n    schedule: /**\n     * Schedule a callback to be called after some delay.\n     *\n     * Returns a function that when executed will cancel the scheduled function.\n     * @param {?} taskFn\n     * @param {?} delay\n     * @return {?}\n     */\n    function (taskFn, delay) { var /** @type {?} */ id = window.setTimeout(taskFn, delay); return function () { return window.clearTimeout(id); }; },\n    /**\n     * Schedule a callback to be called before the next render.\n     * (If `window.requestAnimationFrame()` is not available, use `scheduler.schedule()` instead.)\n     *\n     * Returns a function that when executed will cancel the scheduled function.\n     */\n    scheduleBeforeRender: /**\n     * Schedule a callback to be called before the next render.\n     * (If `window.requestAnimationFrame()` is not available, use `scheduler.schedule()` instead.)\n     *\n     * Returns a function that when executed will cancel the scheduled function.\n     * @param {?} taskFn\n     * @return {?}\n     */\n    function (taskFn) {\n        // TODO(gkalpak): Implement a better way of accessing `requestAnimationFrame()`\n        //                (e.g. accounting for vendor prefix, SSR-compatibility, etc).\n        if (typeof window.requestAnimationFrame === 'undefined') {\n            var /** @type {?} */ frameMs = 16;\n            return scheduler.schedule(taskFn, frameMs);\n        }\n        var /** @type {?} */ id = window.requestAnimationFrame(taskFn);\n        return function () { return window.cancelAnimationFrame(id); };\n    },\n};\n/**\n * Convert a camelCased string to kebab-cased.\n * @param {?} input\n * @return {?}\n */\nfunction camelToDashCase(input) {\n    return input.replace(/[A-Z]/g, function (char) { return \"-\" + char.toLowerCase(); });\n}\n/**\n * Create a `CustomEvent` (even on browsers where `CustomEvent` is not a constructor).\n * @param {?} doc\n * @param {?} name\n * @param {?} detail\n * @return {?}\n */\nfunction createCustomEvent(doc, name, detail) {\n    var /** @type {?} */ bubbles = false;\n    var /** @type {?} */ cancelable = false;\n    // On IE9-11, `CustomEvent` is not a constructor.\n    if (typeof CustomEvent !== 'function') {\n        var /** @type {?} */ event_1 = doc.createEvent('CustomEvent');\n        event_1.initCustomEvent(name, bubbles, cancelable, detail);\n        return event_1;\n    }\n    return new CustomEvent(name, { bubbles: bubbles, cancelable: cancelable, detail: detail });\n}\n/**\n * Check whether the input is an `Element`.\n * @param {?} node\n * @return {?}\n */\nfunction isElement(node) {\n    return node.nodeType === Node.ELEMENT_NODE;\n}\n/**\n * Check whether the input is a function.\n * @param {?} value\n * @return {?}\n */\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\n/**\n * Convert a kebab-cased string to camelCased.\n * @param {?} input\n * @return {?}\n */\n\n/**\n * Check whether an `Element` matches a CSS selector.\n * @param {?} element\n * @param {?} selector\n * @return {?}\n */\nfunction matchesSelector(element, selector) {\n    return matches.call(element, selector);\n}\n/**\n * Test two values for strict equality, accounting for the fact that `NaN !== NaN`.\n * @param {?} value1\n * @param {?} value2\n * @return {?}\n */\nfunction strictEquals(value1, value2) {\n    return value1 === value2 || (value1 !== value1 && value2 !== value2);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} host\n * @param {?} ngContentSelectors\n * @return {?}\n */\nfunction extractProjectableNodes(host, ngContentSelectors) {\n    var /** @type {?} */ nodes = host.childNodes;\n    var /** @type {?} */ projectableNodes = ngContentSelectors.map(function () { return []; });\n    var /** @type {?} */ wildcardIndex = -1;\n    ngContentSelectors.some(function (selector, i) {\n        if (selector === '*') {\n            wildcardIndex = i;\n            return true;\n        }\n        return false;\n    });\n    for (var /** @type {?} */ i = 0, /** @type {?} */ ii = nodes.length; i < ii; ++i) {\n        var /** @type {?} */ node = nodes[i];\n        var /** @type {?} */ ngContentIndex = findMatchingIndex(node, ngContentSelectors, wildcardIndex);\n        if (ngContentIndex !== -1) {\n            projectableNodes[ngContentIndex].push(node);\n        }\n    }\n    return projectableNodes;\n}\n/**\n * @param {?} node\n * @param {?} selectors\n * @param {?} defaultIndex\n * @return {?}\n */\nfunction findMatchingIndex(node, selectors, defaultIndex) {\n    var /** @type {?} */ matchingIndex = defaultIndex;\n    if (isElement(node)) {\n        selectors.some(function (selector, i) {\n            if ((selector !== '*') && matchesSelector(node, selector)) {\n                matchingIndex = i;\n                return true;\n            }\n            return false;\n        });\n    }\n    return matchingIndex;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Time in milliseconds to wait before destroying the component ref when disconnected.\n */\nvar DESTROY_DELAY = 10;\n/**\n * Factory that creates new ComponentNgElementStrategy instances with the strategy factory's\n * injector. A new strategy instance is created with the provided component factory which will\n * create its components on connect.\n *\n * \\@experimental\n */\nvar ComponentNgElementStrategyFactory = /** @class */ (function () {\n    function ComponentNgElementStrategyFactory(component, injector) {\n        this.component = component;\n        this.injector = injector;\n        this.componentFactory =\n            injector.get(_angular_core.ComponentFactoryResolver).resolveComponentFactory(component);\n    }\n    /**\n     * @param {?} injector\n     * @return {?}\n     */\n    ComponentNgElementStrategyFactory.prototype.create = /**\n     * @param {?} injector\n     * @return {?}\n     */\n    function (injector) {\n        return new ComponentNgElementStrategy(this.componentFactory, injector);\n    };\n    return ComponentNgElementStrategyFactory;\n}());\n/**\n * Creates and destroys a component ref using a component factory and handles change detection\n * in response to input changes.\n *\n * \\@experimental\n */\nvar ComponentNgElementStrategy = /** @class */ (function () {\n    function ComponentNgElementStrategy(componentFactory, injector) {\n        this.componentFactory = componentFactory;\n        this.injector = injector;\n        /**\n         * Changes that have been made to the component ref since the last time onChanges was called.\n         */\n        this.inputChanges = null;\n        /**\n         * Whether the created component implements the onChanges function.\n         */\n        this.implementsOnChanges = false;\n        /**\n         * Whether a change detection has been scheduled to run on the component.\n         */\n        this.scheduledChangeDetectionFn = null;\n        /**\n         * Callback function that when called will cancel a scheduled destruction on the component.\n         */\n        this.scheduledDestroyFn = null;\n        /**\n         * Initial input values that were set before the component was created.\n         */\n        this.initialInputValues = new Map();\n        /**\n         * Set of inputs that were not initially set when the component was created.\n         */\n        this.uninitializedInputs = new Set();\n    }\n    /**\n     * Initializes a new component if one has not yet been created and cancels any scheduled\n     * destruction.\n     */\n    /**\n     * Initializes a new component if one has not yet been created and cancels any scheduled\n     * destruction.\n     * @param {?} element\n     * @return {?}\n     */\n    ComponentNgElementStrategy.prototype.connect = /**\n     * Initializes a new component if one has not yet been created and cancels any scheduled\n     * destruction.\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        // If the element is marked to be destroyed, cancel the task since the component was reconnected\n        if (this.scheduledDestroyFn !== null) {\n            this.scheduledDestroyFn();\n            this.scheduledDestroyFn = null;\n            return;\n        }\n        if (!this.componentRef) {\n            this.initializeComponent(element);\n        }\n    };\n    /**\n     * Schedules the component to be destroyed after some small delay in case the element is just\n     * being moved across the DOM.\n     */\n    /**\n     * Schedules the component to be destroyed after some small delay in case the element is just\n     * being moved across the DOM.\n     * @return {?}\n     */\n    ComponentNgElementStrategy.prototype.disconnect = /**\n     * Schedules the component to be destroyed after some small delay in case the element is just\n     * being moved across the DOM.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // Return if there is no componentRef or the component is already scheduled for destruction\n        if (!this.componentRef || this.scheduledDestroyFn !== null) {\n            return;\n        }\n        // Schedule the component to be destroyed after a small timeout in case it is being\n        // moved elsewhere in the DOM\n        this.scheduledDestroyFn = scheduler.schedule(function () {\n            if (_this.componentRef) {\n                /** @type {?} */ ((_this.componentRef)).destroy();\n                _this.componentRef = null;\n            }\n        }, DESTROY_DELAY);\n    };\n    /**\n     * Returns the component property value. If the component has not yet been created, the value is\n     * retrieved from the cached initialization values.\n     */\n    /**\n     * Returns the component property value. If the component has not yet been created, the value is\n     * retrieved from the cached initialization values.\n     * @param {?} property\n     * @return {?}\n     */\n    ComponentNgElementStrategy.prototype.getInputValue = /**\n     * Returns the component property value. If the component has not yet been created, the value is\n     * retrieved from the cached initialization values.\n     * @param {?} property\n     * @return {?}\n     */\n    function (property) {\n        if (!this.componentRef) {\n            return this.initialInputValues.get(property);\n        }\n        return (/** @type {?} */ (this.componentRef.instance))[property];\n    };\n    /**\n     * Sets the input value for the property. If the component has not yet been created, the value is\n     * cached and set when the component is created.\n     */\n    /**\n     * Sets the input value for the property. If the component has not yet been created, the value is\n     * cached and set when the component is created.\n     * @param {?} property\n     * @param {?} value\n     * @return {?}\n     */\n    ComponentNgElementStrategy.prototype.setInputValue = /**\n     * Sets the input value for the property. If the component has not yet been created, the value is\n     * cached and set when the component is created.\n     * @param {?} property\n     * @param {?} value\n     * @return {?}\n     */\n    function (property, value) {\n        if (strictEquals(value, this.getInputValue(property))) {\n            return;\n        }\n        if (!this.componentRef) {\n            this.initialInputValues.set(property, value);\n            return;\n        }\n        this.recordInputChange(property, value);\n        (/** @type {?} */ (this.componentRef.instance))[property] = value;\n        this.scheduleDetectChanges();\n    };\n    /**\n     * Creates a new component through the component factory with the provided element host and\n     * sets up its initial inputs, listens for outputs changes, and runs an initial change detection.\n     */\n    /**\n     * Creates a new component through the component factory with the provided element host and\n     * sets up its initial inputs, listens for outputs changes, and runs an initial change detection.\n     * @param {?} element\n     * @return {?}\n     */\n    ComponentNgElementStrategy.prototype.initializeComponent = /**\n     * Creates a new component through the component factory with the provided element host and\n     * sets up its initial inputs, listens for outputs changes, and runs an initial change detection.\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        var /** @type {?} */ childInjector = _angular_core.Injector.create({ providers: [], parent: this.injector });\n        var /** @type {?} */ projectableNodes = extractProjectableNodes(element, this.componentFactory.ngContentSelectors);\n        this.componentRef = this.componentFactory.create(childInjector, projectableNodes, element);\n        this.implementsOnChanges =\n            isFunction((/** @type {?} */ ((this.componentRef.instance))).ngOnChanges);\n        this.initializeInputs();\n        this.initializeOutputs();\n        this.detectChanges();\n        var /** @type {?} */ applicationRef = this.injector.get(_angular_core.ApplicationRef);\n        applicationRef.attachView(this.componentRef.hostView);\n    };\n    /** Set any stored initial inputs on the component's properties. */\n    /**\n     * Set any stored initial inputs on the component's properties.\n     * @return {?}\n     */\n    ComponentNgElementStrategy.prototype.initializeInputs = /**\n     * Set any stored initial inputs on the component's properties.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this.componentFactory.inputs.forEach(function (_a) {\n            var propName = _a.propName;\n            var /** @type {?} */ initialValue = _this.initialInputValues.get(propName);\n            if (initialValue) {\n                _this.setInputValue(propName, initialValue);\n            }\n            else {\n                // Keep track of inputs that were not initialized in case we need to know this for\n                // calling ngOnChanges with SimpleChanges\n                // Keep track of inputs that were not initialized in case we need to know this for\n                // calling ngOnChanges with SimpleChanges\n                _this.uninitializedInputs.add(propName);\n            }\n        });\n        this.initialInputValues.clear();\n    };\n    /** Sets up listeners for the component's outputs so that the events stream emits the events. */\n    /**\n     * Sets up listeners for the component's outputs so that the events stream emits the events.\n     * @return {?}\n     */\n    ComponentNgElementStrategy.prototype.initializeOutputs = /**\n     * Sets up listeners for the component's outputs so that the events stream emits the events.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ eventEmitters = this.componentFactory.outputs.map(function (_a) {\n            var propName = _a.propName, templateName = _a.templateName;\n            var /** @type {?} */ emitter = /** @type {?} */ ((/** @type {?} */ (((_this.componentRef)).instance))[propName]);\n            return rxjs_operator_map.map.call(emitter, function (value) { return ({ name: templateName, value: value }); });\n        });\n        this.events = rxjs_observable_merge.merge.apply(void 0, eventEmitters);\n    };\n    /** Calls ngOnChanges with all the inputs that have changed since the last call. */\n    /**\n     * Calls ngOnChanges with all the inputs that have changed since the last call.\n     * @return {?}\n     */\n    ComponentNgElementStrategy.prototype.callNgOnChanges = /**\n     * Calls ngOnChanges with all the inputs that have changed since the last call.\n     * @return {?}\n     */\n    function () {\n        if (!this.implementsOnChanges || this.inputChanges === null) {\n            return;\n        }\n        // Cache the changes and set inputChanges to null to capture any changes that might occur\n        // during ngOnChanges.\n        var /** @type {?} */ inputChanges = this.inputChanges;\n        this.inputChanges = null;\n        (/** @type {?} */ ((((this.componentRef)).instance))).ngOnChanges(inputChanges);\n    };\n    /**\n     * Schedules change detection to run on the component.\n     * Ignores subsequent calls if already scheduled.\n     */\n    /**\n     * Schedules change detection to run on the component.\n     * Ignores subsequent calls if already scheduled.\n     * @return {?}\n     */\n    ComponentNgElementStrategy.prototype.scheduleDetectChanges = /**\n     * Schedules change detection to run on the component.\n     * Ignores subsequent calls if already scheduled.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this.scheduledChangeDetectionFn) {\n            return;\n        }\n        this.scheduledChangeDetectionFn = scheduler.scheduleBeforeRender(function () {\n            _this.scheduledChangeDetectionFn = null;\n            _this.detectChanges();\n        });\n    };\n    /**\n     * Records input changes so that the component receives SimpleChanges in its onChanges function.\n     */\n    /**\n     * Records input changes so that the component receives SimpleChanges in its onChanges function.\n     * @param {?} property\n     * @param {?} currentValue\n     * @return {?}\n     */\n    ComponentNgElementStrategy.prototype.recordInputChange = /**\n     * Records input changes so that the component receives SimpleChanges in its onChanges function.\n     * @param {?} property\n     * @param {?} currentValue\n     * @return {?}\n     */\n    function (property, currentValue) {\n        // Do not record the change if the component does not implement `OnChanges`.\n        if (this.componentRef && !this.implementsOnChanges) {\n            return;\n        }\n        if (this.inputChanges === null) {\n            this.inputChanges = {};\n        }\n        // If there already is a change, modify the current value to match but leave the values for\n        // previousValue and isFirstChange.\n        var /** @type {?} */ pendingChange = this.inputChanges[property];\n        if (pendingChange) {\n            pendingChange.currentValue = currentValue;\n            return;\n        }\n        var /** @type {?} */ isFirstChange = this.uninitializedInputs.has(property);\n        this.uninitializedInputs.delete(property);\n        var /** @type {?} */ previousValue = isFirstChange ? undefined : this.getInputValue(property);\n        this.inputChanges[property] = new _angular_core.SimpleChange(previousValue, currentValue, isFirstChange);\n    };\n    /** Runs change detection on the component. */\n    /**\n     * Runs change detection on the component.\n     * @return {?}\n     */\n    ComponentNgElementStrategy.prototype.detectChanges = /**\n     * Runs change detection on the component.\n     * @return {?}\n     */\n    function () {\n        if (!this.componentRef) {\n            return;\n        }\n        this.callNgOnChanges(); /** @type {?} */\n        ((this.componentRef)).changeDetectorRef.detectChanges();\n    };\n    return ComponentNgElementStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class constructor based on an Angular Component to be used for custom element registration.\n *\n * \\@experimental\n * @record\n */\n\n/**\n * Class that extends HTMLElement and implements the functionality needed for a custom element.\n *\n * \\@experimental\n * @abstract\n */\nvar NgElement = /** @class */ (function (_super) {\n    __extends(NgElement, _super);\n    function NgElement() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.ngElementEventsSubscription = null;\n        return _this;\n    }\n    return NgElement;\n}(HTMLElement));\n/**\n * Initialization configuration for the NgElementConstructor. Provides the strategy factory\n * that produces a strategy for each instantiated element. Additionally, provides a function\n * that takes the component factory and provides a map of which attributes should be observed on\n * the element and which property they are associated with.\n *\n * \\@experimental\n * @record\n */\n\n/**\n * Gets a map of default set of attributes to observe and the properties they affect.\n * @param {?} inputs\n * @return {?}\n */\nfunction getDefaultAttributeToPropertyInputs(inputs) {\n    var /** @type {?} */ attributeToPropertyInputs = {};\n    inputs.forEach(function (_a) {\n        var propName = _a.propName, templateName = _a.templateName;\n        attributeToPropertyInputs[camelToDashCase(templateName)] = propName;\n    });\n    return attributeToPropertyInputs;\n}\n/**\n * Gets a component's set of inputs. Uses the injector to get the component factory where the inputs\n * are defined.\n * @param {?} component\n * @param {?} injector\n * @return {?}\n */\nfunction getComponentInputs(component, injector) {\n    var /** @type {?} */ componentFactoryResolver = injector.get(_angular_core.ComponentFactoryResolver);\n    var /** @type {?} */ componentFactory = componentFactoryResolver.resolveComponentFactory(component);\n    return componentFactory.inputs;\n}\n/**\n * \\@whatItDoes Creates a custom element class based on an Angular Component. Takes a configuration\n * that provides initialization information to the created class. E.g. the configuration's injector\n * will be the initial injector set on the class which will be used for each created instance.\n *\n * \\@description Builds a class that encapsulates the functionality of the provided component and\n * uses the config's information to provide more context to the class. Takes the component factory's\n * inputs and outputs to convert them to the proper custom element API and add hooks to input\n * changes. Passes the config's injector to each created instance (may be overriden with the\n * static property to affect all newly created instances, or as a constructor argument for\n * one-off creations).\n *\n * \\@experimental\n * @template P\n * @param {?} component\n * @param {?} config\n * @return {?}\n */\nfunction createNgElementConstructor(component, config) {\n    var /** @type {?} */ inputs = getComponentInputs(component, config.injector);\n    var /** @type {?} */ strategyFactory = config.strategyFactory ||\n        new ComponentNgElementStrategyFactory(component, config.injector);\n    var /** @type {?} */ attributeToPropertyInputs = config.attributeToPropertyInputs || getDefaultAttributeToPropertyInputs(inputs);\n    var NgElementImpl = /** @class */ (function (_super) {\n        __extends(NgElementImpl, _super);\n        function NgElementImpl(injector) {\n            var _this = _super.call(this) || this;\n            _this.ngElementStrategy = strategyFactory.create(injector || config.injector);\n            return _this;\n        }\n        /**\n         * @param {?} attrName\n         * @param {?} oldValue\n         * @param {?} newValue\n         * @param {?=} namespace\n         * @return {?}\n         */\n        NgElementImpl.prototype.attributeChangedCallback = /**\n         * @param {?} attrName\n         * @param {?} oldValue\n         * @param {?} newValue\n         * @param {?=} namespace\n         * @return {?}\n         */\n        function (attrName, oldValue, newValue, namespace) {\n            var /** @type {?} */ propName = /** @type {?} */ ((attributeToPropertyInputs[attrName]));\n            this.ngElementStrategy.setInputValue(propName, newValue);\n        };\n        /**\n         * @return {?}\n         */\n        NgElementImpl.prototype.connectedCallback = /**\n         * @return {?}\n         */\n        function () {\n            var _this = this;\n            this.ngElementStrategy.connect(this);\n            // Listen for events from the strategy and dispatch them as custom events\n            this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe(function (e) {\n                var /** @type {?} */ customEvent = createCustomEvent(_this.ownerDocument, e.name, e.value);\n                _this.dispatchEvent(customEvent);\n            });\n        };\n        /**\n         * @return {?}\n         */\n        NgElementImpl.prototype.disconnectedCallback = /**\n         * @return {?}\n         */\n        function () {\n            this.ngElementStrategy.disconnect();\n            if (this.ngElementEventsSubscription) {\n                this.ngElementEventsSubscription.unsubscribe();\n                this.ngElementEventsSubscription = null;\n            }\n        };\n        NgElementImpl.observedAttributes = Object.keys(attributeToPropertyInputs);\n        return NgElementImpl;\n    }(NgElement));\n    inputs.map(function (_a) {\n        var propName = _a.propName;\n        return propName;\n    }).forEach(function (property) {\n        Object.defineProperty(NgElementImpl.prototype, property, {\n            get: function () { return this.ngElementStrategy.getInputValue(property); },\n            set: function (newValue) { this.ngElementStrategy.setInputValue(property, newValue); },\n            configurable: true,\n            enumerable: true,\n        });\n    });\n    return /** @type {?} */ ((/** @type {?} */ (NgElementImpl)));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * \\@experimental\n */\nvar VERSION = new _angular_core.Version('6.0.0-beta.6-10cd543ab9');\n\nexports.NgElement = NgElement;\nexports.createNgElementConstructor = createNgElementConstructor;\nexports.VERSION = VERSION;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=elements.umd.js.map\n"]}