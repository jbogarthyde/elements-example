{"version":3,"sources":["elements.umd.js"],"names":["global","factory","exports","module","require","define","amd","ng","elements","core","Rx","Observable","prototype","this","_angular_core","rxjs_observable_merge","rxjs_operator_map","__extends","d","b","__","constructor","extendStatics","Object","create","camelToKebabCase","input","replace","char","toLowerCase","createCustomEvent","doc","name","detail","CustomEvent","event_1","createEvent","initCustomEvent","bubbles","cancelable","isElement","node","nodeType","Node","ELEMENT_NODE","isFunction","value","matchesSelector","element","selector","matches","call","strictEquals","value1","value2","extractProjectableNodes","host","ngContentSelectors","nodes","childNodes","projectableNodes","map","wildcardIndex","some","i","ii","length","ngContentIndex","findMatchingIndex","push","selectors","defaultIndex","matchingIndex","getConfigFromComponentFactory","componentFactory","injector","attributeToPropertyInputs","Map","inputs","forEach","_a","propName","templateName","attr","set","strategyFactory","ComponentFactoryNgElementStrategyFactory","propertyInputs","createNgElementConstructor","config","NgElementImpl","_super","strategyFactoryOverride","_this","ngElementStrategy","attributeChangedCallback","attrName","oldValue","newValue","namespace","get","setPropertyValue","connectedCallback","getAttribute","connect","ngElementEventsSubscription","events","subscribe","e","customEvent","ownerDocument","dispatchEvent","disconnectedCallback","disconnect","unsubscribe","observedAttributes","Array","from","keys","NgElement","property","defineProperty","getPropertyValue","configurable","enumerable","setPrototypeOf","__proto__","p","hasOwnProperty","elProto","Element","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","scheduler","schedule","taskFn","delay","id","window","setTimeout","clearTimeout","scheduleBeforeRender","requestAnimationFrame","cancelAnimationFrame","ComponentFactoryNgElementStrategy","inputChanges","implementsOnChanges","scheduledChangeDetectionFn","scheduledDestroyFn","initialInputValues","uninitializedInputs","Set","componentRef","initializeComponent","destroy","recordInputChange","scheduleDetectChanges","childInjector","Injector","providers","parent","ngOnChanges","initializeInputs","initializeOutputs","detectChanges","ApplicationRef","attachView","hostView","initialValue","add","clear","eventEmitters","outputs","emitter","merge","apply","callNgOnChanges","currentValue","pendingChange","isFirstChange","has","delete","previousValue","undefined","SimpleChange","changeDetectorRef","arguments","HTMLElement","VERSION","Version"],"mappings":"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","file":"elements.umd.min.js","sourcesContent":["/**\n * @license Angular v6.0.0-beta.5-8531ff3335\n * (c) 2010-2018 Google, Inc. https://angular.io/\n * License: MIT\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs/observable/merge'), require('rxjs/operator/map')) :\n\ttypeof define === 'function' && define.amd ? define('@angular/elements', ['exports', '@angular/core', 'rxjs/observable/merge', 'rxjs/operator/map'], factory) :\n\t(factory((global.ng = global.ng || {}, global.ng.elements = {}),global.ng.core,global.Rx.Observable,global.Rx.Observable.prototype));\n}(this, (function (exports,_angular_core,rxjs_observable_merge,rxjs_operator_map) { 'use strict';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/**\n * @license Angular v6.0.0-beta.5-8531ff3335\n * (c) 2010-2018 Google, Inc. https://angular.io/\n * License: MIT\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar elProto = /** @type {?} */ (Element.prototype);\nvar matches = elProto.matches || elProto.matchesSelector || elProto.mozMatchesSelector ||\n    elProto.msMatchesSelector || elProto.oMatchesSelector || elProto.webkitMatchesSelector;\n/**\n * Provide methods for scheduling the execution of a callback.\n */\nvar scheduler = {\n    /**\n     * Schedule a callback to be called after some delay.\n     *\n     * Returns a function that when executed will cancel the scheduled function.\n     */\n    schedule: /**\n     * Schedule a callback to be called after some delay.\n     *\n     * Returns a function that when executed will cancel the scheduled function.\n     * @param {?} taskFn\n     * @param {?} delay\n     * @return {?}\n     */\n    function (taskFn, delay) { var /** @type {?} */ id = window.setTimeout(taskFn, delay); return function () { return window.clearTimeout(id); }; },\n    /**\n     * Schedule a callback to be called before the next render.\n     * (If `window.requestAnimationFrame()` is not available, use `scheduler.schedule()` instead.)\n     *\n     * Returns a function that when executed will cancel the scheduled function.\n     */\n    scheduleBeforeRender: /**\n     * Schedule a callback to be called before the next render.\n     * (If `window.requestAnimationFrame()` is not available, use `scheduler.schedule()` instead.)\n     *\n     * Returns a function that when executed will cancel the scheduled function.\n     * @param {?} taskFn\n     * @return {?}\n     */\n    function (taskFn) {\n        // TODO(gkalpak): Implement a better way of accessing `requestAnimationFrame()`\n        //                (e.g. accounting for vendor prefix, SSR-compatibility, etc).\n        if (typeof window.requestAnimationFrame === 'undefined') {\n            var /** @type {?} */ frameMs = 16;\n            return scheduler.schedule(taskFn, frameMs);\n        }\n        var /** @type {?} */ id = window.requestAnimationFrame(taskFn);\n        return function () { return window.cancelAnimationFrame(id); };\n    },\n};\n/**\n * Convert a camelCased string to kebab-cased.\n * @param {?} input\n * @return {?}\n */\nfunction camelToKebabCase(input) {\n    return input.replace(/[A-Z]/g, function (char) { return \"-\" + char.toLowerCase(); });\n}\n/**\n * Create a `CustomEvent` (even on browsers where `CustomEvent` is not a constructor).\n * @param {?} doc\n * @param {?} name\n * @param {?} detail\n * @return {?}\n */\nfunction createCustomEvent(doc, name, detail) {\n    var /** @type {?} */ bubbles = false;\n    var /** @type {?} */ cancelable = false;\n    // On IE9-11, `CustomEvent` is not a constructor.\n    if (typeof CustomEvent !== 'function') {\n        var /** @type {?} */ event_1 = doc.createEvent('CustomEvent');\n        event_1.initCustomEvent(name, bubbles, cancelable, detail);\n        return event_1;\n    }\n    return new CustomEvent(name, { bubbles: bubbles, cancelable: cancelable, detail: detail });\n}\n/**\n * Check whether the input is an `Element`.\n * @param {?} node\n * @return {?}\n */\nfunction isElement(node) {\n    return node.nodeType === Node.ELEMENT_NODE;\n}\n/**\n * Check whether the input is a function.\n * @param {?} value\n * @return {?}\n */\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\n/**\n * Convert a kebab-cased string to camelCased.\n * @param {?} input\n * @return {?}\n */\n\n/**\n * Check whether an `Element` matches a CSS selector.\n * @param {?} element\n * @param {?} selector\n * @return {?}\n */\nfunction matchesSelector(element, selector) {\n    return matches.call(element, selector);\n}\n/**\n * Test two values for strict equality, accounting for the fact that `NaN !== NaN`.\n * @param {?} value1\n * @param {?} value2\n * @return {?}\n */\nfunction strictEquals(value1, value2) {\n    return value1 === value2 || (value1 !== value1 && value2 !== value2);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} host\n * @param {?} ngContentSelectors\n * @return {?}\n */\nfunction extractProjectableNodes(host, ngContentSelectors) {\n    var /** @type {?} */ nodes = host.childNodes;\n    var /** @type {?} */ projectableNodes = ngContentSelectors.map(function () { return []; });\n    var /** @type {?} */ wildcardIndex = -1;\n    ngContentSelectors.some(function (selector, i) {\n        if (selector === '*') {\n            wildcardIndex = i;\n            return true;\n        }\n        return false;\n    });\n    for (var /** @type {?} */ i = 0, /** @type {?} */ ii = nodes.length; i < ii; ++i) {\n        var /** @type {?} */ node = nodes[i];\n        var /** @type {?} */ ngContentIndex = findMatchingIndex(node, ngContentSelectors, wildcardIndex);\n        if (ngContentIndex !== -1) {\n            projectableNodes[ngContentIndex].push(node);\n        }\n    }\n    return projectableNodes;\n}\n/**\n * @param {?} node\n * @param {?} selectors\n * @param {?} defaultIndex\n * @return {?}\n */\nfunction findMatchingIndex(node, selectors, defaultIndex) {\n    var /** @type {?} */ matchingIndex = defaultIndex;\n    if (isElement(node)) {\n        selectors.some(function (selector, i) {\n            if ((selector !== '*') && matchesSelector(node, selector)) {\n                matchingIndex = i;\n                return true;\n            }\n            return false;\n        });\n    }\n    return matchingIndex;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Time in milliseconds to wait before destroying the component ref when disconnected.\n */\nvar DESTROY_DELAY = 10;\n/**\n * Creates an NgElementConfig based on the provided component factory and injector. By default,\n * the observed attributes on the NgElement will be the kebab-case version of the component inputs.\n *\n * \\@experimental\n * @param {?} componentFactory\n * @param {?} injector\n * @return {?}\n */\nfunction getConfigFromComponentFactory(componentFactory, injector) {\n    var /** @type {?} */ attributeToPropertyInputs = new Map();\n    componentFactory.inputs.forEach(function (_a) {\n        var propName = _a.propName, templateName = _a.templateName;\n        var /** @type {?} */ attr = camelToKebabCase(templateName);\n        attributeToPropertyInputs.set(attr, propName);\n    });\n    return {\n        strategyFactory: new ComponentFactoryNgElementStrategyFactory(componentFactory, injector),\n        propertyInputs: componentFactory.inputs.map(function (_a) {\n            var propName = _a.propName;\n            return propName;\n        }),\n        attributeToPropertyInputs: attributeToPropertyInputs,\n    };\n}\n/**\n * Factory that creates new ComponentFactoryNgElementStrategy instances with the strategy factory's\n * injector. A new strategy instance is created with the provided component factory which will\n * create its components on connect.\n *\n * \\@experimental\n */\nvar ComponentFactoryNgElementStrategyFactory = /** @class */ (function () {\n    function ComponentFactoryNgElementStrategyFactory(componentFactory, injector) {\n        this.componentFactory = componentFactory;\n        this.injector = injector;\n    }\n    /**\n     * @return {?}\n     */\n    ComponentFactoryNgElementStrategyFactory.prototype.create = /**\n     * @return {?}\n     */\n    function () { return new ComponentFactoryNgElementStrategy(this.componentFactory, this.injector); };\n    return ComponentFactoryNgElementStrategyFactory;\n}());\n/**\n * Creates and destroys a component ref using a component factory and handles change detection\n * in response to input changes.\n *\n * \\@experimental\n */\nvar ComponentFactoryNgElementStrategy = /** @class */ (function () {\n    function ComponentFactoryNgElementStrategy(componentFactory, injector) {\n        this.componentFactory = componentFactory;\n        this.injector = injector;\n        /**\n         * Changes that have been made to the component ref since the last time onChanges was called.\n         */\n        this.inputChanges = null;\n        /**\n         * Whether the created component implements the onChanges function.\n         */\n        this.implementsOnChanges = false;\n        /**\n         * Whether a change detection has been scheduled to run on the component.\n         */\n        this.scheduledChangeDetectionFn = null;\n        /**\n         * Callback function that when called will cancel a scheduled destruction on the component.\n         */\n        this.scheduledDestroyFn = null;\n        /**\n         * Initial input values that were set before the component was created.\n         */\n        this.initialInputValues = new Map();\n        /**\n         * Set of inputs that were not initially set when the component was created.\n         */\n        this.uninitializedInputs = new Set();\n    }\n    /**\n     * Initializes a new component if one has not yet been created and cancels any scheduled\n     * destruction.\n     */\n    /**\n     * Initializes a new component if one has not yet been created and cancels any scheduled\n     * destruction.\n     * @param {?} element\n     * @return {?}\n     */\n    ComponentFactoryNgElementStrategy.prototype.connect = /**\n     * Initializes a new component if one has not yet been created and cancels any scheduled\n     * destruction.\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        // If the element is marked to be destroyed, cancel the task since the component was reconnected\n        if (this.scheduledDestroyFn !== null) {\n            this.scheduledDestroyFn();\n            this.scheduledDestroyFn = null;\n            return;\n        }\n        if (!this.componentRef) {\n            this.initializeComponent(element);\n        }\n    };\n    /**\n     * Schedules the component to be destroyed after some small delay in case the element is just\n     * being moved across the DOM.\n     */\n    /**\n     * Schedules the component to be destroyed after some small delay in case the element is just\n     * being moved across the DOM.\n     * @return {?}\n     */\n    ComponentFactoryNgElementStrategy.prototype.disconnect = /**\n     * Schedules the component to be destroyed after some small delay in case the element is just\n     * being moved across the DOM.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // Return if there is no componentRef or the component is already scheduled for destruction\n        if (!this.componentRef || this.scheduledDestroyFn !== null) {\n            return;\n        }\n        // Schedule the component to be destroyed after a small timeout in case it is being\n        // moved elsewhere in the DOM\n        this.scheduledDestroyFn =\n            scheduler.schedule(function () { /** @type {?} */ ((_this.componentRef)).destroy(); }, DESTROY_DELAY);\n    };\n    /**\n     * Returns the component property value. If the component has not yet been created, the value is\n     * retrieved from the cached initialization values.\n     */\n    /**\n     * Returns the component property value. If the component has not yet been created, the value is\n     * retrieved from the cached initialization values.\n     * @param {?} property\n     * @return {?}\n     */\n    ComponentFactoryNgElementStrategy.prototype.getPropertyValue = /**\n     * Returns the component property value. If the component has not yet been created, the value is\n     * retrieved from the cached initialization values.\n     * @param {?} property\n     * @return {?}\n     */\n    function (property) {\n        if (!this.componentRef) {\n            return this.initialInputValues.get(property);\n        }\n        return (/** @type {?} */ (this.componentRef.instance))[property];\n    };\n    /**\n     * Sets the input value for the property. If the component has not yet been created, the value is\n     * cached and set when the component is created.\n     */\n    /**\n     * Sets the input value for the property. If the component has not yet been created, the value is\n     * cached and set when the component is created.\n     * @param {?} property\n     * @param {?} value\n     * @return {?}\n     */\n    ComponentFactoryNgElementStrategy.prototype.setPropertyValue = /**\n     * Sets the input value for the property. If the component has not yet been created, the value is\n     * cached and set when the component is created.\n     * @param {?} property\n     * @param {?} value\n     * @return {?}\n     */\n    function (property, value) {\n        if (strictEquals(value, this.getPropertyValue(property))) {\n            return;\n        }\n        if (!this.componentRef) {\n            this.initialInputValues.set(property, value);\n            return;\n        }\n        this.recordInputChange(property, value);\n        (/** @type {?} */ (this.componentRef.instance))[property] = value;\n        this.scheduleDetectChanges();\n    };\n    /**\n     * Creates a new component through the component factory with the provided element host and\n     * sets up its initial inputs, listens for outputs changes, and runs an initial change detection.\n     */\n    /**\n     * Creates a new component through the component factory with the provided element host and\n     * sets up its initial inputs, listens for outputs changes, and runs an initial change detection.\n     * @param {?} element\n     * @return {?}\n     */\n    ComponentFactoryNgElementStrategy.prototype.initializeComponent = /**\n     * Creates a new component through the component factory with the provided element host and\n     * sets up its initial inputs, listens for outputs changes, and runs an initial change detection.\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        var /** @type {?} */ childInjector = _angular_core.Injector.create({ providers: [], parent: this.injector });\n        var /** @type {?} */ projectableNodes = extractProjectableNodes(element, this.componentFactory.ngContentSelectors);\n        this.componentRef = this.componentFactory.create(childInjector, projectableNodes, element);\n        this.implementsOnChanges =\n            isFunction((/** @type {?} */ ((this.componentRef.instance))).ngOnChanges);\n        this.initializeInputs();\n        this.initializeOutputs();\n        this.detectChanges();\n        var /** @type {?} */ applicationRef = this.injector.get(_angular_core.ApplicationRef);\n        applicationRef.attachView(this.componentRef.hostView);\n    };\n    /** Set any stored initial inputs on the component's properties. */\n    /**\n     * Set any stored initial inputs on the component's properties.\n     * @return {?}\n     */\n    ComponentFactoryNgElementStrategy.prototype.initializeInputs = /**\n     * Set any stored initial inputs on the component's properties.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this.componentFactory.inputs.forEach(function (_a) {\n            var propName = _a.propName;\n            var /** @type {?} */ initialValue = _this.initialInputValues.get(propName);\n            if (initialValue) {\n                _this.setPropertyValue(propName, initialValue);\n            }\n            else {\n                // Keep track of inputs that were not initialized in case we need to know this for\n                // calling ngOnChanges with SimpleChanges\n                // Keep track of inputs that were not initialized in case we need to know this for\n                // calling ngOnChanges with SimpleChanges\n                _this.uninitializedInputs.add(propName);\n            }\n        });\n        this.initialInputValues.clear();\n    };\n    /** Sets up listeners for the component's outputs so that the events stream emits the events. */\n    /**\n     * Sets up listeners for the component's outputs so that the events stream emits the events.\n     * @return {?}\n     */\n    ComponentFactoryNgElementStrategy.prototype.initializeOutputs = /**\n     * Sets up listeners for the component's outputs so that the events stream emits the events.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ eventEmitters = this.componentFactory.outputs.map(function (_a) {\n            var propName = _a.propName, templateName = _a.templateName;\n            var /** @type {?} */ emitter = /** @type {?} */ ((/** @type {?} */ (((_this.componentRef)).instance))[propName]);\n            return rxjs_operator_map.map.call(emitter, function (value) { return ({ name: templateName, value: value }); });\n        });\n        this.events = rxjs_observable_merge.merge.apply(void 0, eventEmitters);\n    };\n    /** Calls ngOnChanges with all the inputs that have changed since the last call. */\n    /**\n     * Calls ngOnChanges with all the inputs that have changed since the last call.\n     * @return {?}\n     */\n    ComponentFactoryNgElementStrategy.prototype.callNgOnChanges = /**\n     * Calls ngOnChanges with all the inputs that have changed since the last call.\n     * @return {?}\n     */\n    function () {\n        if (!this.implementsOnChanges || this.inputChanges === null) {\n            return;\n        }\n        (/** @type {?} */ ((((this.componentRef)).instance))).ngOnChanges(this.inputChanges);\n        this.inputChanges = null;\n    };\n    /**\n     * Schedules change detection to run on the component.\n     * Ignores subsequent calls if already scheduled.\n     */\n    /**\n     * Schedules change detection to run on the component.\n     * Ignores subsequent calls if already scheduled.\n     * @return {?}\n     */\n    ComponentFactoryNgElementStrategy.prototype.scheduleDetectChanges = /**\n     * Schedules change detection to run on the component.\n     * Ignores subsequent calls if already scheduled.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this.scheduledChangeDetectionFn) {\n            return;\n        }\n        this.scheduledChangeDetectionFn = scheduler.scheduleBeforeRender(function () {\n            _this.detectChanges();\n            _this.scheduledChangeDetectionFn = null;\n        });\n    };\n    /**\n     * Records input changes so that the component receives SimpleChanges in its onChanges function.\n     */\n    /**\n     * Records input changes so that the component receives SimpleChanges in its onChanges function.\n     * @param {?} property\n     * @param {?} currentValue\n     * @return {?}\n     */\n    ComponentFactoryNgElementStrategy.prototype.recordInputChange = /**\n     * Records input changes so that the component receives SimpleChanges in its onChanges function.\n     * @param {?} property\n     * @param {?} currentValue\n     * @return {?}\n     */\n    function (property, currentValue) {\n        // Do not record the change if the component does not implement `OnChanges`.\n        if (!this.componentRef || !this.implementsOnChanges) {\n            return;\n        }\n        if (this.inputChanges === null) {\n            this.inputChanges = {};\n        }\n        // If there already is a change, modify the current value to match but leave the values for\n        // previousValue and isFirstChange.\n        var /** @type {?} */ pendingChange = this.inputChanges[property];\n        if (pendingChange) {\n            pendingChange.currentValue = currentValue;\n            return;\n        }\n        var /** @type {?} */ isFirstChange = this.uninitializedInputs.has(property);\n        this.uninitializedInputs.delete(property);\n        var /** @type {?} */ previousValue = isFirstChange ? undefined : this.getPropertyValue(property);\n        this.inputChanges[property] = new _angular_core.SimpleChange(previousValue, currentValue, isFirstChange);\n    };\n    /** Runs change detection on the component. */\n    /**\n     * Runs change detection on the component.\n     * @return {?}\n     */\n    ComponentFactoryNgElementStrategy.prototype.detectChanges = /**\n     * Runs change detection on the component.\n     * @return {?}\n     */\n    function () {\n        if (!this.componentRef) {\n            return;\n        }\n        this.callNgOnChanges(); /** @type {?} */\n        ((this.componentRef)).changeDetectorRef.detectChanges();\n    };\n    return ComponentFactoryNgElementStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class constructor based on an Angular Component to be used for custom element registration.\n *\n * \\@experimental\n * @record\n */\n\n/**\n * Class that extends HTMLElement and implements the functionality needed for a custom element.\n *\n * \\@experimental\n * @abstract\n */\nvar NgElement = /** @class */ (function (_super) {\n    __extends(NgElement, _super);\n    function NgElement() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.ngElementEventsSubscription = null;\n        return _this;\n    }\n    return NgElement;\n}(HTMLElement));\n/**\n * Initialization configuration for the NgElementConstructor. Provides the strategy factory\n * that produces a strategy for each instantiated element. Additionally, provides a function\n * that takes the component factory and provides a map of which attributes should be observed on\n * the element and which property they are associated with.\n *\n * \\@experimental\n * @record\n */\n\n/**\n * \\@whatItDoes Creates a custom element class based on an Angular Component. Takes a configuration\n * that provides initialization information to the created class. E.g. the configuration's injector\n * will be the initial injector set on the class which will be used for each created instance.\n *\n * \\@description Builds a class that encapsulates the functionality of the provided component and\n * uses the config's information to provide more context to the class. Takes the component factory's\n * inputs and outputs to convert them to the proper custom element API and add hooks to input\n * changes. Passes the config's injector to each created instance (may be overriden with the\n * static property to affect all newly created instances, or as a constructor argument for\n * one-off creations).\n *\n * \\@experimental\n * @template P\n * @param {?} config\n * @return {?}\n */\nfunction createNgElementConstructor(config) {\n    var NgElementImpl = /** @class */ (function (_super) {\n        __extends(NgElementImpl, _super);\n        function NgElementImpl(strategyFactoryOverride) {\n            var _this = _super.call(this) || this;\n            // Use the constructor's strategy factory override if it is present, otherwise default to\n            // the config's factory.\n            var /** @type {?} */ strategyFactory = strategyFactoryOverride || config.strategyFactory;\n            _this.ngElementStrategy = strategyFactory.create();\n            return _this;\n        }\n        /**\n         * @param {?} attrName\n         * @param {?} oldValue\n         * @param {?} newValue\n         * @param {?=} namespace\n         * @return {?}\n         */\n        NgElementImpl.prototype.attributeChangedCallback = /**\n         * @param {?} attrName\n         * @param {?} oldValue\n         * @param {?} newValue\n         * @param {?=} namespace\n         * @return {?}\n         */\n        function (attrName, oldValue, newValue, namespace) {\n            var /** @type {?} */ propName = /** @type {?} */ ((config.attributeToPropertyInputs.get(attrName)));\n            this.ngElementStrategy.setPropertyValue(propName, newValue);\n        };\n        /**\n         * @return {?}\n         */\n        NgElementImpl.prototype.connectedCallback = /**\n         * @return {?}\n         */\n        function () {\n            var _this = this;\n            // Take element attribute inputs and set them as inputs on the strategy\n            config.attributeToPropertyInputs.forEach(function (propName, attrName) {\n                var /** @type {?} */ value = _this.getAttribute(attrName);\n                if (value) {\n                    _this.ngElementStrategy.setPropertyValue(propName, value);\n                }\n            });\n            this.ngElementStrategy.connect(this);\n            // Listen for events from the strategy and dispatch them as custom events\n            this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe(function (e) {\n                var /** @type {?} */ customEvent = createCustomEvent(_this.ownerDocument, e.name, e.value);\n                _this.dispatchEvent(customEvent);\n            });\n        };\n        /**\n         * @return {?}\n         */\n        NgElementImpl.prototype.disconnectedCallback = /**\n         * @return {?}\n         */\n        function () {\n            this.ngElementStrategy.disconnect();\n            if (this.ngElementEventsSubscription) {\n                this.ngElementEventsSubscription.unsubscribe();\n                this.ngElementEventsSubscription = null;\n            }\n        };\n        NgElementImpl.observedAttributes = Array.from(config.attributeToPropertyInputs.keys());\n        return NgElementImpl;\n    }(NgElement));\n    config.propertyInputs.forEach(function (property) {\n        Object.defineProperty(NgElementImpl.prototype, property, {\n            get: function () { return this.ngElementStrategy.getPropertyValue(property); },\n            set: function (newValue) { this.ngElementStrategy.setPropertyValue(property, newValue); },\n            configurable: true,\n            enumerable: true,\n        });\n    });\n    return /** @type {?} */ ((/** @type {?} */ (NgElementImpl)));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * \\@experimental\n */\nvar VERSION = new _angular_core.Version('6.0.0-beta.5-8531ff3335');\n\nexports.ComponentFactoryNgElementStrategy = ComponentFactoryNgElementStrategy;\nexports.ComponentFactoryNgElementStrategyFactory = ComponentFactoryNgElementStrategyFactory;\nexports.getConfigFromComponentFactory = getConfigFromComponentFactory;\nexports.NgElement = NgElement;\nexports.createNgElementConstructor = createNgElementConstructor;\nexports.VERSION = VERSION;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=elements.umd.js.map\n"]}